# -*- coding: utf-8 -*-
"""Date_Parsing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15Gx8Osk0A8sm8m0iaHpNuYXYBgL67j8q

The input date string is of one of the following forms:
 "14 Feb 1985"


 "12 March, 1965"

 "7, September, 2009"

 "1,jan 2012"

That is: the day is a number, the month name is in text--may be shortened to three letters, may be capitalized, with the yyyy at the end
The three pieces may be separated by
a comma, or

a space, or

a comma followed by a space

there may be two different separators

Output expected: 7-digit integer yyyyddd where ddd is the nth day of the year
"""

import re
def is_leap_year(year):
    return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)

def parse_date(input_date):
    # Convert month names to numerical values
    month_dict = {
        "jan": 1, "feb": 2, "mar": 3, "apr": 4,
        "may": 5, "jun": 6, "jul": 7, "aug": 8,
        "sep": 9, "oct": 10, "nov": 11, "dec": 12
    }

    # Split the input date by space or comma
    parts = re.split(r"[, ]+", input_date.lower())

    # Ensure we have exactly three parts
    if len(parts) != 3:
        return "Invalid date format"

    # Extract day, month, and year
    day, month, year = parts

    # Check if month is valid
    if len(month) < 3 or month[:3] not in month_dict:
        return "Invalid month"

    month = month_dict[month[:3]]

    # Check if day is numeric
    if not day.isdigit():
        return "Invalid day"

    day = int(day)

    # Check if year is numeric
    if not year.isdigit() or len(year) != 4:
        return "Invalid year"

    year = int(year)

    # Check if day is valid for the month
    if month == 2:
        if is_leap_year(year):
            max_day = 29
        else:
            max_day = 28
    elif month in [4, 6, 9, 11]:
        max_day = 30
    else:
        max_day = 31

    if day < 1 or day > max_day:
        return f"Invalid day for {input_date}"

    # Calculate ordinal date
    ordinal_date = sum([31, 29 if is_leap_year(year) else 28, 31, 30, 31, 30, 31, 31, 30, 31, 30][:month - 1]) + day

    # Format as 7-digit integer
    return int(str(year) + '{:03d}'.format(ordinal_date))

# Test cases
dates = [
    "14 Feb 1985",
    "12 March, 1965",
    "7, September, 2009",
    "1,jan 2012",
    "Invalid Date",
    "31 Feb 2000",
    "29 Feb 2023"
]

for date in dates:
    print(parse_date(date))

from dateutil import parser

def parse_date(input_date):
    try:
        # Parse the input date
        parsed_date = parser.parse(input_date)

        # Convert parsed date to the desired format (Julian date)
        ordinal_date = parsed_date.timetuple().tm_yday
        julian_date = int(str(parsed_date.year) + '{:03d}'.format(ordinal_date))

        return julian_date
    except Exception as e:
        return str(e)

# Test cases
dates = [
    "14 Feb 1985",
    "12 March, 1965",
    "7, September, 2009",
    "1,jan 2012",
    "Invalid Date",
    "31 Feb 2000",
    "29 Feb 2023"
]

for date in dates:
    print(parse_date(date))

